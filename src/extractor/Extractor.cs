using common;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text.Json.Nodes;
using System.Threading;
using System.Threading.Tasks;

namespace extractor;

internal delegate ValueTask RunExtractor(CancellationToken cancellationToken);
internal delegate ValueTask<bool> ShouldExtract(ResourceKey resourceKey, CancellationToken cancellationToken);
internal delegate ValueTask WriteResource(ResourceKey resourceKey, Option<JsonObject> dtoOption, CancellationToken cancellationToken);

internal static class ExtractorModule
{
    public static void ConfigureRunExtractor(IHostApplicationBuilder builder)
    {
        ResourceGraphModule.ConfigureResourceGraph(builder);
        ResourceModule.ConfigureIsResourceSupportedInApim(builder);
        ResourceModule.ConfigureListResourceNamesFromApim(builder);
        ResourceModule.ConfigureListResourceDtosFromApim(builder);
        ConfigureShouldExtract(builder);
        ConfigureWriteResource(builder);

        builder.TryAddSingleton(ResolveRunExtractor);
    }

    private static RunExtractor ResolveRunExtractor(IServiceProvider provider)
    {
        var graph = provider.GetRequiredService<ResourceGraph>();
        var isSkuSupported = provider.GetRequiredService<IsResourceSupportedInApim>();
        var listResourceNames = provider.GetRequiredService<ListResourceNamesFromApim>();
        var listResourceDtos = provider.GetRequiredService<ListResourceDtosFromApim>();
        var shouldExtract = provider.GetRequiredService<ShouldExtract>();
        var writeResource = provider.GetRequiredService<WriteResource>();
        var activitySource = provider.GetRequiredService<ActivitySource>();
        var logger = provider.GetRequiredService<ILogger>();

        return async cancellationToken =>
        {
            using var _ = activitySource.StartActivity("run.extractor");

            logger.LogInformation("Running extractor...");

            await graph.ListTraversalRootResources()
                       .IterTaskParallel(async resource => await processResource(resource, ParentChain.Empty, cancellationToken),
                                         maxDegreeOfParallelism: Option.None,
                                         cancellationToken);

            logger.LogInformation("Extractor completed successfully.");
        };

        async ValueTask processResource(IResource resource, ParentChain parents, CancellationToken cancellationToken)
        {
            if (await isSkuSupported(resource, cancellationToken) is false)
            {
                logger.LogWarning("Skipping {Resource} as they are not supported in the APIM SKU.", resource.PluralName);
                return;
            }

            await listNamesAndDtos(resource, parents, cancellationToken)
                    .IterTaskParallel(async x => await extractResource(resource, x.Name, x.Dto, parents, cancellationToken),
                                      maxDegreeOfParallelism: Option.None,
                                      cancellationToken);
        }

        IAsyncEnumerable<(ResourceName Name, Option<JsonObject> Dto)> listNamesAndDtos(IResource resource, ParentChain parents, CancellationToken cancellationToken) =>
            resource switch
            {
                IResourceWithDto resourceWithDto =>
                    from x in listResourceDtos(resourceWithDto, parents, cancellationToken)
                    select (x.Name, Option.Some(x.Dto)),
                _ => from name in listResourceNames(resource, parents, cancellationToken)
                     select (name, Option<JsonObject>.None())
            };

        async ValueTask extractResource(IResource resource, ResourceName name, Option<JsonObject> dtoOption, ParentChain parents, CancellationToken cancellationToken)
        {
            var resourceKey = new ResourceKey { Resource = resource, Name = name, Parents = parents };

            // Skip the resource if it should not be extracted.
            if (await shouldExtract(resourceKey, cancellationToken) is false)
            {
                return;
            }

            // Write the resource's artifacts
            await writeResource(resourceKey, dtoOption, cancellationToken);

            // Process the resource's successors
            var successorParents = parents.Append(resource, name);
            await graph.ListTraversalSuccessors(resource)
                       // Only extract releases under the current API
                       .Where(successor => resource is not ApiResource || successor is not ApiReleaseResource || ApiRevisionModule.IsRootName(name))
                       .IterTaskParallel(async successor => await processResource(successor, successorParents, cancellationToken),
                                         maxDegreeOfParallelism: Option.None,
                                         cancellationToken);
        }
    }

    private static void ConfigureShouldExtract(IHostApplicationBuilder builder)
    {
        ConfigurationModule.ConfigureResourceIsInConfiguration(builder);

        builder.TryAddSingleton(ResolveShouldExtract);
    }

    private static ShouldExtract ResolveShouldExtract(IServiceProvider provider)
    {
        var resourceIsInConfiguration = provider.GetRequiredService<ResourceIsInConfiguration>();
        var activitySource = provider.GetRequiredService<ActivitySource>();
        var logger = provider.GetRequiredService<ILogger>();

        return async (resourceKey, cancellationToken) =>
        {
            using var activity = activitySource.StartActivity("should.extract")
                                              ?.SetTag("resourceKey", resourceKey);

            var extract = await shouldExtract(resourceKey, cancellationToken);

            activity?.SetTag("extract", extract);

            return extract;
        };

        async ValueTask<bool> shouldExtract(ResourceKey resourceKey, CancellationToken cancellationToken)
        {
            var resource = resourceKey.Resource;
            var name = resourceKey.Name;
            var parents = resourceKey.Parents;

            // Never extract the `master` subscription
            if (resource is SubscriptionResource && name == SubscriptionResource.Master)
            {
                logger.LogWarning("Skipping master subscription '{Name}'...", name);
                return false;
            }
            // Never extract system groups
            else if (resource is GroupResource
                     && (name == GroupResource.Administrators || name == GroupResource.Developers || name == GroupResource.Guests))
            {
                logger.LogWarning("Skipping system group '{Name}'...", name);
                return false;
            }
            // Check from configuration. If no configuration was defined for the resource type, extract all.
            else
            {
                var option = await resourceIsInConfiguration(resourceKey, cancellationToken);

                // Log a warning if the resource should be skipped.
                option.Where(result => result is false)
                      .Iter(_ => logger.LogWarning("Skipping {ResourceKey} as it is not in configuration...", resourceKey));

                return option.IfNone(() => true);
            }
        }
    }

    private static void ConfigureWriteResource(IHostApplicationBuilder builder)
    {
        ResourceModule.ConfigureWriteInformationFile(builder);
        ResourceModule.ConfigureWritePolicyFile(builder);
        ResourceModule.ConfigureGetApiSpecificationFromApim(builder);
        ResourceModule.ConfigureWriteApiSpecificationFile(builder);

        builder.TryAddSingleton(ResolveWriteResource);
    }

    private static WriteResource ResolveWriteResource(IServiceProvider provider)
    {
        var writeInformationFile = provider.GetRequiredService<WriteInformationFile>();
        var writePolicyFile = provider.GetRequiredService<WritePolicyFile>();
        var getApiSpecification = provider.GetRequiredService<GetApiSpecificationFromApim>();
        var writeApiSpecificationFile = provider.GetRequiredService<WriteApiSpecificationFile>();
        var activitySource = provider.GetRequiredService<ActivitySource>();
        var logger = provider.GetRequiredService<ILogger>();

        return async (resourceKey, dtoOption, cancellationToken) =>
        {
            using var _ = activitySource.StartActivity("write.resource")
                                       ?.SetTag("resourceKey", resourceKey);

            await dtoOption.IterTask(async dto =>
            {
                var resource = resourceKey.Resource;
                var name = resourceKey.Name;
                var parents = resourceKey.Parents;

                if (resource is IResourceWithInformationFile resourceWithInformationFile)
                {
                    logger.LogInformation("Writing information file for {ResourceKey}...", resourceKey);
                    await writeInformationFile(resourceWithInformationFile, name, dto, parents, cancellationToken);
                }

                if (resource is IPolicyResource policyResource)
                {
                    logger.LogInformation("Writing policy file for {ResourceKey}...", resourceKey);
                    await writePolicyFile(policyResource, name, dto, parents, cancellationToken);
                }

                if (resource is ApiResource)
                {
                    var option = await getApiSpecification(name, dto, cancellationToken);
                    await option.IterTask(async tuple =>
                    {
                        var (specification, contents) = tuple;

                        logger.LogInformation("Writing specification file for {ResourceKey}...", resourceKey);
                        await writeApiSpecificationFile(name, specification, contents, cancellationToken);
                    });
                }
            });
        };
    }
}